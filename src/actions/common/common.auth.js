const { Scenes, Composer } = require("telegraf");
const { createUser } = require("../../controllers/user.controller");
const {
  getAllDepartments,
} = require("../../controllers/department.controller");
const reply = require("../../utils/text.util");
const { createBtn, createHeader } = require("../../utils/ui.util");
const validation = require("../../utils/validation.util");

// Functions
async function showDepartments(ctx) {
  // Create text
  const title = "–í –∫–∞–∫–æ–º –æ—Ç–¥–µ–ª–µ —Ç—ã —Ä–∞–±–æ—Ç–∞–µ—à—å? üè¢";
  const description = "–í—ã–±–µ—Ä–∏ <i>–æ—Ç–¥–µ–ª</i> –∏–∑ —Å–ø–∏—Å–∫–∞.";
  const answer = createHeader(title, description, false);

  // Create UI
  const departments = await getAllDepartments();
  const keyboard = departments.map((department) => {
    return [
      {
        text: department.name,
        callback_data: `select_department_${department.id}`,
      },
    ];
  });

  // Send
  const message = ctx.replyWithHTML(answer, {
    reply_markup: {
      inline_keyboard: keyboard,
    },
  });

  // Save message ID
  ctx.session.sceneMessages = message.message_id;
}

// Action init
const stepOne = new Composer();
const stepTwo = new Composer();
const startThree = new Composer();

// Action steps
stepOne.action("getName", async (ctx) => {
  await ctx.deleteMessage(ctx.session.sceneMessages);

  const title = "–ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç? üòÅ";
  const description =
    "–ù–∞–ø–∏—à–∏ <i>—Ñ–∞–º–∏–ª–∏—é</i> –∏ <i>–∏–º—è</i> —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª. –ù–∞–ø—Ä–∏–º–µ—Ä: <i>–ö—É–∑–Ω–µ—Ü–æ–≤ –ò–ª—å—è</i>.";
  const answer = createHeader(title, description, false);

  const message = await ctx.replyWithHTML(answer);
  ctx.session.sceneMessages = message.message_id;

  return ctx.wizard.next();
});
stepTwo.on("text", async (ctx) => {
  const fullName = ctx.message.text;

  // Validate
  if (!validation.validateText(fullName)) {
    return ctx.replyWithHTML(
      "–ù–µ–µ–µ–µ... üòÖ –¢–∞–∫–∞—è <i>—Ñ–∞–º–∏–ª–∏—è</i> –∏ <i>–∏–º—è</i> –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç."
    );
  }
  if (!validation.hasTwoWords(fullName)) {
    return ctx.replyWithHTML("–ù—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å <i>—Ñ–∞–º–∏–ª–∏—é</i> –∏ <i>–∏–º—è</i>.");
  }
  if (validation.hasCensorship(fullName)) {
    return ctx.replyWithHTML(
      "–ù—É –∑–∞—á–µ–º —Ç–∞–∫? ü´§ –ù—É–∂–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å <i>—Ñ–∞–º–∏–ª–∏—é</i> –∏ <i>–∏–º—è</i>."
    );
  }

  // Send
  await showDepartments(ctx);
  ctx.session.fullName = fullName;

  return ctx.wizard.next();
});
startThree.action(/select_department_(.+)/, async (ctx) => {
  const departmentId = ctx.match[1];

  // Create new user
  await createUser(ctx.chat.id, ctx.session.fullName, departmentId);

  // Delete old message
  await ctx.deleteMessage(ctx.session.sceneMessages);

  // Go to next scene
  await ctx.scene.leave();
  return ctx.scene.enter("COMMON_START_ACTION");
});

// Create action
const authScene = new Scenes.WizardScene(
  "COMMON_AUTH_ACTION",
  stepOne,
  stepTwo,
  startThree
);
authScene.enter(async (ctx) => {
  const answer = reply.welcome.newUser;
  const keyboard = createBtn("–î–∞–≤–∞–π –∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è üî•", "getName");

  const message = await ctx.replyWithHTML(answer, keyboard);
  ctx.session.sceneMessages = message.message_id;
});

module.exports = { authScene };
